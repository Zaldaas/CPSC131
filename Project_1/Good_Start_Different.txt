#include <cassert>
#include <iostream>
#include <string>

template <typename T>
class MyVector {
private:
    size_t size_ = 0;
    size_t capacity_ = 0;
    T* elements_ = nullptr;

    void changeCapacity(size_t c) {
        if (c < size_) {
            throw std::range_error("New capacity is less than the current number of elements.");
        }

        T* e = new T[c];
        for (size_t i = 0; i < size_; i++) {
            e[i] = elements_[i];
        }

        delete[] elements_;
        elements_ = e;
        capacity_ = c;
    }

    void copyOther(const MyVector& other) {
        size_ = other.size_;
        capacity_ = other.capacity_;
        elements_ = new T[capacity_];
        for (size_t i = 0; i < size_; i++) {
            elements_[i] = other.elements_[i];
        }
    }

public:
    static constexpr size_t DEFAULT_CAPACITY = 64;
    static constexpr size_t MINIMUM_CAPACITY = 8;

    MyVector(size_t capacity = DEFAULT_CAPACITY) {
        if (capacity < MINIMUM_CAPACITY) {
            capacity = MINIMUM_CAPACITY;
        }

        capacity_ = capacity;
        elements_ = new T[capacity_];
    }

    MyVector(const MyVector& other) {
        copyOther(other);
    }

    ~MyVector() {
        clear();
        delete[] elements_;
        elements_ = nullptr;
    }

    MyVector& operator=(const MyVector& rhs) {
        if (this != &rhs) {
            clear();
            copyOther(rhs);
        }
        return *this;
    }

    T& operator[](size_t index) const {
        assert(index < size_);
        return elements_[index];
    }

    size_t size() const {
        return size_;
    }

    size_t capacity() const {
        return capacity_;
    }

    bool empty() const {
        return size_ == 0;
    }

    T& at(size_t index) const {
        if (index >= size_) {
            throw std::out_of_range("Index out of bounds.");
        }
        return elements_[index];
    }

    void reserve(size_t c) {
        if (c > capacity_) {
            changeCapacity(c);
        }
    }

    T& set(size_t index, const T& element) {
        if (index >= size_) {
            throw std::out_of_range("Index out of bounds.");
        }
        elements_[index] = element;
        return elements_[index];
    }

    T& push_back(const T& element) {
        insert(size_, element);
        return elements_[size_ - 1];
    }

    void pop_back() {
        erase(size_ - 1);
    }

    void insert(size_t index, const T& element) {
        if (size_ == capacity_) {
            changeCapacity(2 * capacity_);
        }
        for (size_t i = size_; i > index; i--) {
            elements_[i] = elements_[i - 1];
        }
        elements_[index] = element;
        size_++;
    }

    void erase(size_t index) {
        for (size_t i = index; i < size_ - 1; i++) {
            elements_[i] = elements_[i + 1];
        }
        size_--;
    }

    void clear() {
        for (size_t i = 0; i < size
