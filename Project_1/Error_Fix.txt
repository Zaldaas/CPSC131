#include <assert.h>
#include <iostream>
#include <string>

template <typename T>
class MyVector
{
public:
  static constexpr size_t DEFAULT_CAPACITY = 64;
  static constexpr size_t MINIMUM_CAPACITY = 8;

  MyVector(size_t capacity = DEFAULT_CAPACITY) {
    arrCapacity = capacity;
    arrSize = 0;
    arr = new T[arrCapacity];
  }

  MyVector(const MyVector& other) {
    arrCapacity = other.arrCapacity;
    arrSize = other.arrSize;
    arr = new T[arrCapacity];
    for (size_t i = 0; i < arrSize; i++) {
      arr[i] = other.arr[i];
    }
  }

  ~MyVector() {
    clear();
    delete[] arr;
    arr = nullptr;
  }

  MyVector& operator=(const MyVector& rhs) {
    if (this != &rhs) {
      clear();
      delete[] arr;
      arrCapacity = rhs.arrCapacity;
      arrSize = rhs.arrSize;
      arr = new T[arrCapacity];
      for (size_t i = 0; i < arrSize; i++) {
        arr[i] = rhs.arr[i];
      }
    }
    return *this;
  }

  T& operator[](size_t index) const {
    return arr[index];
  }

  size_t size() const {
    return arrSize;
  }

  size_t capacity() const {
    return arrCapacity;
  }

  bool empty() const {
    return (arrSize == 0);
  }

  T& at(size_t index) const {
    if (index >= arrSize) {
      throw std::out_of_range("Index out of bounds");
    }
    return arr[index];
  }

  void reserve(size_t capacity) {
    if (arrCapacity < capacity) {
      changeCapacity(capacity);
    }
  }

  T& set(size_t index, const T& element) {
    if (index >= arrSize) {
      throw std::out_of_range("Index out of bounds");
    }
    arr[index] = element;
    return arr[index];
  }

  // Add other missing functions here

private:
  size_t arrCapacity;
  size_t arrSize;
  T* arr;

  void clear() {
    for (size_t i = 0; i < arrSize; i++) {
      arr[i].~T();
    }
    arrSize = 0;
  }

  void changeCapacity(size_t capacity) {
    assert(capacity >= MINIMUM_CAPACITY);
    T* newArr = new T[capacity];
    for (size_t i = 0; i < arrSize; i++) {
      newArr[i] = arr[i];
    }
    delete[] arr;
    arr = newArr;
arrCapacity = arrCapacity;
}

/**
 * Helper function for inserting an element into our array
 * Should be called by push_back() to avoid repeating code
 * Returns a reference to the newly added element (not the original)
 */
T& insert(size_t index, const T& element) {
  if (arrSize >= arrCapacity) {
    changeCapacity(arrCapacity * 2);
  }
  for (size_t i = arrSize; i > index; i--) {
    arr[i] = arr[i - 1];
  }
  arr[index] = element;
  arrSize++;
  return arr[index];
}
};